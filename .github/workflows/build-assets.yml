# -------------------------------------------------------------------
# Build Frontend Assets & Commit to master
# -------------------------------------------------------------------
# Laravel Mix (webpack) build — outputs:
#   public/js/app.js, public/js/vendor.js, public/js/manifest.js
#   public/css/app.css
#   public/mix-manifest.json
#
# Hostinger shared hosting has no Node.js, so we build here and
# commit the compiled assets back into the branch.
# -------------------------------------------------------------------

name: Build Assets

on:
  push:
    branches: [master]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: build-assets-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-commit:
    # Skip if the last commit was made by this workflow (prevent infinite loop)
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js 16
        uses: actions/setup-node@v4
        with:
          # Node 16 required — Laravel Mix 6 + PostCSS 8.2 are incompatible
          # with Node 18+ (ERR_PACKAGE_PATH_NOT_EXPORTED on postcss/package.json)
          node-version: 16
          cache: yarn

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Build production assets
        run: yarn prod

      # ---------------------------------------------------------------
      # Verification Step 1: Build output existence & size
      # ---------------------------------------------------------------
      - name: Verify build output exists
        run: |
          echo "--- Checking build artifacts ---"
          for f in public/js/app.js public/js/vendor.js public/js/manifest.js public/css/app.css public/mix-manifest.json; do
            if [ ! -f "$f" ]; then
              echo "ERROR: $f is missing!"
              exit 1
            fi
            SIZE=$(wc -c < "$f")
            echo "OK: $f ($SIZE bytes)"
            if [ "$SIZE" -lt 500 ]; then
              echo "WARNING: $f seems too small ($SIZE bytes) — possible placeholder?"
            fi
          done
          echo "--- All build artifacts present ---"

      # ---------------------------------------------------------------
      # Verification Step 2: Vue bootstrap sanity check
      # Fail if app.js does NOT contain the Vue mount call.
      # In minified webpack output, the pattern is:
      #   .$mount("#app")  or  .$mount('#app')
      # We also check for "new Vue" or "new X.default" as a secondary signal.
      # ---------------------------------------------------------------
      - name: Verify Vue bootstrap in app.js
        run: |
          echo "--- Verifying Vue bootstrap code in public/js/app.js ---"

          if grep -qP '\.\$mount\(' public/js/app.js; then
            echo "OK: Found \$mount() call in app.js"
          else
            echo "ERROR: public/js/app.js does NOT contain a \$mount() call!"
            echo "Vue will not mount and raw {{ }} bindings will be visible."
            exit 1
          fi

          # Secondary check: the app.js entry module must exist as a proper
          # webpack chunk, not be empty or truncated.
          if grep -qP 'webpackChunk' public/js/app.js; then
            echo "OK: app.js is a valid webpack chunk"
          else
            echo "ERROR: app.js does not look like a valid webpack chunk!"
            exit 1
          fi

          # Verify the runtime (manifest.js) has the chunk-installed tracking
          if grep -qP 'webpackChunk' public/js/manifest.js; then
            echo "OK: manifest.js contains the webpack runtime"
          else
            echo "ERROR: manifest.js does not contain the webpack runtime!"
            exit 1
          fi

          echo "--- Vue bootstrap verification passed ---"

      # ---------------------------------------------------------------
      # Verification Step 3: Webpack chunk dependency check
      # Ensure every chunk ID that app.js depends on is either:
      #   a) pre-installed in the manifest.js runtime, OR
      #   b) delivered by a .js file under public/js/
      # If not, the entry callback will never fire (Vue won't mount).
      # ---------------------------------------------------------------
      - name: Verify webpack chunk dependencies are satisfiable
        run: |
          echo "--- Verifying webpack chunk dependencies ---"
          node - <<'SCRIPT'
          const fs = require('fs');
          const path = require('path');

          const jsDir = 'public/js';
          const appContent = fs.readFileSync(path.join(jsDir, 'app.js'), 'utf8');
          const manifestContent = fs.readFileSync(path.join(jsDir, 'manifest.js'), 'utf8');

          // 1. Find entry-point dependency array, e.g. .O(void 0,[170,898],…)
          const depMatch = appContent.match(/\.O\(void 0,\[([0-9,]+)\]/);
          if (!depMatch) {
            console.log('OK: No chunk dependency array found (single-chunk build).');
            process.exit(0);
          }
          const requiredIds = depMatch[1].split(',').map(Number);
          console.log('Entry requires chunks:', requiredIds);

          // 2. Find pre-installed chunk IDs in manifest.js runtime
          const installedMatch = manifestContent.match(/var \w=\{((?:\d+:\d+,?)+)\}/);
          const installedIds = new Set();
          if (installedMatch) {
            installedMatch[1].split(',').forEach(p => {
              installedIds.add(parseInt(p.split(':')[0], 10));
            });
          }
          console.log('Pre-installed in runtime:', [...installedIds]);

          // 3. Find chunk IDs delivered by JS files
          const deliveredIds = new Set();
          const jsFiles = fs.readdirSync(jsDir).filter(f => f.endsWith('.js'));
          for (const f of jsFiles) {
            const content = fs.readFileSync(path.join(jsDir, f), 'utf8');
            const chunkMatch = content.match(/\.push\(\[\[([0-9,]+)\]/);
            if (chunkMatch) {
              chunkMatch[1].split(',').map(Number).forEach(id => deliveredIds.add(id));
            }
          }
          console.log('Delivered by JS files:', [...deliveredIds]);

          // 4. Check all required IDs are satisfied
          const allAvailable = new Set([...installedIds, ...deliveredIds]);
          const missing = requiredIds.filter(id => !allAvailable.has(id));

          if (missing.length > 0) {
            console.error(`ERROR: Chunk(s) ${missing.join(', ')} required by app.js entry but NOT available!`);
            console.error('This means the Vue entry callback will never fire.');
            console.error('The PreInstallCssChunks plugin in webpack.mix.js should have patched this.');
            process.exit(1);
          }

          console.log('OK: All required chunk dependencies are satisfiable.');
          SCRIPT
          echo "--- Chunk dependency verification passed ---"

      # ---------------------------------------------------------------
      # Verification Step 4: mix-manifest.json references
      # Fail if mix-manifest references files that do not exist.
      # ---------------------------------------------------------------
      - name: Verify mix-manifest references exist
        run: |
          echo "--- Verifying mix-manifest.json references ---"
          MISSING=0
          # Extract all paths from mix-manifest.json (keys)
          PATHS=$(node -e "
            const m = require('./public/mix-manifest.json');
            Object.keys(m).forEach(k => console.log(k));
          ")
          for REL in $PATHS; do
            FILE="public${REL}"
            # Strip query string for existence check
            FILE=$(echo "$FILE" | sed 's/[?#].*//')
            if [ ! -f "$FILE" ]; then
              echo "MISSING: $REL -> $FILE"
              MISSING=$((MISSING + 1))
            else
              echo "OK: $REL -> $FILE"
            fi
          done
          if [ "$MISSING" -gt 0 ]; then
            echo "ERROR: $MISSING file(s) referenced in mix-manifest.json do not exist!"
            exit 1
          fi
          echo "--- All mix-manifest references verified ---"

      # ---------------------------------------------------------------
      # Verification Step 5: CSS asset references
      # ---------------------------------------------------------------
      - name: Verify CSS asset references
        run: |
          echo "--- Verifying CSS url() asset references ---"
          MISSING=0
          # Extract relative url() paths from compiled CSS (skip data:, http:, https:, #)
          URLS=$(grep -oP 'url\(\K[^)]+' public/css/app.css \
            | sed "s/['\"]//g" \
            | sed 's/[?#].*//' \
            | grep -v '^data:' \
            | grep -v '^https\?:' \
            | grep -v '^#' \
            | sort -u)
          for REL in $URLS; do
            # Resolve relative path from public/css/ directory
            RESOLVED="public/css/$REL"
            # Normalize (handle ../)
            RESOLVED=$(realpath --relative-to=. -m "$RESOLVED")
            if [ ! -f "$RESOLVED" ]; then
              echo "MISSING: $REL -> $RESOLVED"
              MISSING=$((MISSING + 1))
            else
              echo "OK: $REL -> $RESOLVED"
            fi
          done
          if [ "$MISSING" -gt 0 ]; then
            echo "ERROR: $MISSING CSS asset reference(s) could not be resolved!"
            exit 1
          fi
          echo "--- All CSS asset references verified ---"

      # ---------------------------------------------------------------
      # Verification Step 6: Leaflet JS images
      # ---------------------------------------------------------------
      - name: Verify Leaflet JS images exist
        run: |
          echo "--- Verifying Leaflet images for JS (L.Icon.Default.imagePath) ---"
          MISSING=0
          for img in marker-icon.png marker-icon-2x.png marker-shadow.png layers.png layers-2x.png; do
            if [ ! -f "public/images/$img" ]; then
              echo "MISSING: public/images/$img (needed by Leaflet JS)"
              MISSING=$((MISSING + 1))
            else
              echo "OK: public/images/$img"
            fi
          done
          if [ "$MISSING" -gt 0 ]; then
            echo "ERROR: $MISSING Leaflet image(s) missing from public/images/!"
            exit 1
          fi
          echo "--- All Leaflet JS images verified ---"

      # ---------------------------------------------------------------
      # Verification Step 7: Surface assets (planet BG + sprite-grid)
      # ---------------------------------------------------------------
      - name: Verify Surface assets (planet backgrounds + sprite-grid)
        run: |
          echo "--- Verifying Surface PixiJS assets ---"
          MISSING=0
          for i in 1 2 3 4 5 6 7; do
            if [ ! -f "public/images/planet-${i}-bg.png" ]; then
              echo "MISSING: public/images/planet-${i}-bg.png"
              MISSING=$((MISSING + 1))
            else
              SIZE=$(wc -c < "public/images/planet-${i}-bg.png")
              echo "OK: public/images/planet-${i}-bg.png ($SIZE bytes)"
            fi
          done
          if [ ! -f "public/images/sprite-grid.png" ]; then
            echo "MISSING: public/images/sprite-grid.png"
            MISSING=$((MISSING + 1))
          else
            SIZE=$(wc -c < "public/images/sprite-grid.png")
            echo "OK: public/images/sprite-grid.png ($SIZE bytes)"
          fi
          # Verify compiled JS contains the Surface component
          if grep -q 'surface-viewport' public/js/app.js; then
            echo "OK: app.js contains surface-viewport"
          else
            echo "ERROR: app.js does NOT contain surface-viewport!"
            MISSING=$((MISSING + 1))
          fi
          if grep -q 'fetchPlanetDirect' public/js/app.js; then
            echo "OK: app.js contains direct API fallback"
          else
            echo "ERROR: app.js does NOT contain fetchPlanetDirect!"
            MISSING=$((MISSING + 1))
          fi
          if [ "$MISSING" -gt 0 ]; then
            echo "ERROR: $MISSING Surface asset(s) or component checks failed!"
            exit 1
          fi
          echo "--- All Surface assets verified ---"

      # ---------------------------------------------------------------
      # Verification Step 8: Blade asset() references
      # ---------------------------------------------------------------
      - name: Verify Blade asset() references
        run: |
          echo "--- Verifying Blade asset() references ---"
          MISSING=0
          # Extract asset('...') paths from all Blade templates
          ASSETS=$(grep -rhoP "asset\(\s*['\"]([^'\"]+)['\"]\s*\)" resources/views/ \
            | grep -oP "asset\(\s*['\"]\\K[^'\"]+")
          for ASSET in $(echo "$ASSETS" | sort -u); do
            # Skip dynamic placeholders like __resource__
            if echo "$ASSET" | grep -q '__'; then
              echo "SKIP (dynamic): $ASSET"
              continue
            fi
            # Skip tile references (generated at runtime, not committed)
            if echo "$ASSET" | grep -q '^tile/'; then
              echo "SKIP (runtime): $ASSET"
              continue
            fi
            if [ ! -e "public/$ASSET" ]; then
              echo "MISSING: public/$ASSET (referenced by Blade template)"
              MISSING=$((MISSING + 1))
            else
              echo "OK: public/$ASSET"
            fi
          done
          if [ "$MISSING" -gt 0 ]; then
            echo "ERROR: $MISSING Blade asset() reference(s) point to missing files!"
            exit 1
          fi
          echo "--- All Blade asset references verified ---"

      # ---------------------------------------------------------------
      # Commit built assets
      # ---------------------------------------------------------------
      - name: Commit built assets
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Stage ALL build output (use directories to catch any extra chunk files)
          git add -f public/js/
          git add -f public/css/
          git add -f public/mix-manifest.json
          git add -f public/images/

          # Only commit if there are actual changes
          if git diff --cached --quiet; then
            echo "No asset changes to commit."
          else
            git commit -m "chore: rebuild frontend assets [skip ci]"
            git push origin master
            echo "Assets committed and pushed."
          fi
